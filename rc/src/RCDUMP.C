/*++
/* NAME
/*      rcdump 1
/* SUMMARY
/*      Dump mewel rc file
/* SYNOPSIS
/*	rcdump [file]
/* DESCRIPTION
/*	This program dumps the contents of a mewel-generated rc file
/*	so that it can be subjected to regression tests.
/* BUGS
/*	Does not yet handle all Windows constructs.
/* AUTHOR(S)
/*      Wietse Venema
/*	Bisschopsmolen 12
/*	Eindhoven, The Netherlands
/*--*/

#include <stdio.h>
#include <errno.h>

#if !defined(VAXC) && !defined(_MSC_VER)
extern char *sys_errlist[];

#define strerror(e) (sys_errlist[e])
#endif

/* Following should be in stdlib.h or somesuch. */

#ifndef tell
extern long 
tell(int);

#endif
extern long 
lseek(int, long, int);

/* RC compiler internals */

#include "int.h"
#include "rccomp.h"

 /* The following functions are generated by the rc_name script */

extern char *
class_name(int);
extern char *
rt_name(int);
extern char *
res_name(int);
extern char *
mf_name(int);

/* From rc.y.... */

typedef struct
{
  WORD style;
  WORD attr;
  WORD idItem;
} MTIheader;

/* From rcstring.c... */

typedef struct index
{
  int minRange, maxRange;
  unsigned long ulSeekPos;
  unsigned long ulSeekPosEnd;
} INDEX;

typedef struct stringinfo
{
  WORD idxSymbol;		/* symbol table index of the
				 * string */
  WORD idString;		/* id of the string */
} STRINGINFO;

 /* Forward declarations */

void 
eread(int, void *, int);
void 
do_stringtblheader(STRINGTBLHEADER *);
void 
do_resource(void);
void 
unimplemented(char *);
void 
do_menu(void);
void 
do_menu_element(void);
void 
do_mtiheader(MTIheader *);
void 
do_cstring(char *);
void 
do_string(char *, int);
WORD 
do_word(char *);
DWORD 
do_dword(char *);
void 
do_acceltable(void);
void 
do_strings(void);
void 
do_group(INDEX *);
void 
do_dialog(void);
void 
do_resindex(void);

int fd = 0;

BOOL bWindowsCompatDlg = 0;


/* .. */

int 
main(int argc, char **argv)
{
  STRINGTBLHEADER stringtblheader;

  if (argc > 2)
  {
    fprintf(stderr, "usage: %s [file]\n", argv[0]);
    exit(1);
  }
  if (argc == 2 && (fd = open(argv[1], O_RDONLY | O_BINARY, 0)) < 0)
  {
    perror(argv[1]);
    exit(1);
  }
  /*
   * The header describes the location of the table with
   * resource names. 
   */

  do_stringtblheader(&stringtblheader);

  /* Process resource entries */

  while (tell(fd) < stringtblheader.ulSeekPos)
    do_resource();

  /* Process the table with resource names. */

  while (tell(fd) < stringtblheader.ulSeekPos + stringtblheader.ulBytes)
    do_resindex();

  return (0);
}

/* eread - read some data or bust */

void 
eread(int fd, void *data, int len)
{
  if (read(fd, data, len) != len)
  {
    fprintf(stderr, "read error %s at pos %ld\n", strerror(errno), tell(fd));
    exit(1);
  }
}

/* unimplemented - politely inform about a missing feature */

void 
unimplemented(char *what)
{
  fprintf(stderr, "\nSorry, but \"%s\" is not yet implemented\n", what);
  exit(1);
}

/* do_stringtblheader - read/display string table header contents */

void 
do_stringtblheader(p)
  STRINGTBLHEADER *p;
{
  eread(fd, p, sizeof(*p));
  printf("\nSTRINGTBLHEADER\n");
  printf("DWORD ulSignature = %ld\n", p->ulSignature);
  printf("DWORD ulSeekPos   = %ld\n", p->ulSeekPos);
  printf("DWORD ulBytes     = %ld\n", p->ulBytes);
}

/* do_resource - process resource record */

void 
do_resource()
{
  RESOURCE r;

  eread(fd, &r, sizeof(r));

  bWindowsCompatDlg = !(r.bResType == 0xFF);

  printf("\nRESOURCE\n");
  printf("BYTE  bResType   = 0x%x\n", r.bResType);
  printf("WORD  iResType   = 0x%x (%s)\n", r.iResType, rt_name(r.iResType));
  printf("BYTE  bResID     = 0x%x\n", r.bResID);
  printf("WORD  iResID     = %d\n", r.iResID);
  printf("WORD  fResFlags  = 0x%x (%s)\n", r.fResFlags,
	 res_name(r.fResFlags));
  printf("DWORD nResBytes  = %ld\n", r.nResBytes);

  /* Branch on what type of resource we have here */

  switch (r.bResType)
  {
  default:
    fprintf(stderr, "unknown bResType\n");
    exit(1);
    /* NOTREACHED */
  case 0:			/* other type of resource */
    unimplemented("bResType == 0");
    break;
  case 0xFF:			/* regular resource */
    switch (r.iResType)
    {
    default:
      fprintf(stderr, "unknown resource type\n");
      exit(1);
      /* NOTREACHED */
    case RT_CURSOR:
      unimplemented(rt_name(r.iResType));
      break;
    case RT_BITMAP:
      unimplemented(rt_name(r.iResType));
      break;
    case RT_MENU:
      do_menu();
      break;
    case RT_DIALOG:
      do_dialog();
      break;
    case RT_STRING:
      do_strings();
      break;
    case RT_ICON:
      unimplemented(rt_name(r.iResType));
      break;
    case RT_ACCELERATOR:
      do_acceltable();
      break;
    case RT_RCDATA:
      unimplemented(rt_name(r.iResType));
      break;
    case RT_MSGBOX:
      unimplemented(rt_name(r.iResType));
      break;
    }
  }
}

/* do_menu - process menu descriptions */

void 
do_menu()
{
  WORD nmenu;
  static int nest = 0;

  /* Read number of menu elements. */

  nmenu = do_word("\nNumber of menu elements = %d\n");

  printf("\nBEGIN %d\n", nest++);

  while (nmenu-- > 0)
    do_menu_element();

  printf("\nEND %d\n", --nest);
}

/* do_menu_element - process one element of a menu */

void 
do_menu_element()
{
  MTIheader m;

  /* Read menu element type and decide what to do */

  do_mtiheader(&m);
  switch (m.style)
  {
  default:
    fprintf(stderr, "unknown style\n");
    exit(1);
    /* NOTREACHED */
  case MF_POPUP:
    do_cstring("");
    do_menu();
    break;
  case MF_STRING:
    do_cstring("");
    break;
  case MF_SEPARATOR:
    break;
  case MF_CHECKED:
    unimplemented(mf_name(m.style));
    break;
#if 0
  case MF_UNCHECKED:
    unimplemented(mf_name(m.style));
    break;
#endif
  case MF_DISABLED:
    unimplemented(mf_name(m.style));
    break;
#if 0
  case MF_ENABLED:
    unimplemented(mf_name(m.style));
    break;
#endif
  case MF_MENUBREAK:
    unimplemented(mf_name(m.style));
    break;
  case MF_MENUBARBREAK:
    unimplemented(mf_name(m.style));
    break;
#if (MF_MENUBARBREAK != MF_SHADOW)
  case MF_SHADOW:
    unimplemented(mf_name(m.style));
    break;
#endif
  case MF_HELP:
    unimplemented(mf_name(m.style));
    break;
  case MF_BITMAP:
    unimplemented(mf_name(m.style));
    break;
  }
}

/* do_mtiheader - read/display MTIheader structure */

void 
do_mtiheader(m)
  MTIheader *m;
{
  eread(fd, m, sizeof(*m));
  printf("\nMTIHEADER\n");
  printf("WORD style  = 0x%x (%s)\n", m->style, mf_name(m->style));
  printf("WORD attr   = 0x%x\n", m->attr);
  printf("WORD idItem = %d\n", m->idItem);
}

/* do_word - read and display a WORD */

WORD 
do_byte(char *fmt)
{
  char w;

  eread(fd, &w, sizeof(w));
  printf(fmt, w);
  return (w);
}

WORD 
do_short(char *fmt)
{
  short w;

  eread(fd, &w, sizeof(w));
  printf(fmt, w);
  return (w);
}

WORD 
do_word(char *fmt)
{
  WORD w;

  eread(fd, &w, sizeof(w));
  printf(fmt, w);
  return (w);
}

/* do_dword - read and display a DWORD */

DWORD 
do_dword(char *fmt)
{
  DWORD w;

  eread(fd, &w, sizeof(w));
  printf(fmt, w);
  return (w);
}

/* do_string - read/display counted string */

void 
do_string(char *str, int len)
{
  char buf[BUFSIZ];

  printf("%s", str);
  if (len > sizeof(buf))
  {
    fprintf(stderr, "bad string length: %u\n", len);
    exit(1);
  }
  eread(fd, buf, len);
  buf[len] = 0;
  printf("string[%d] = \"%s\"\n", len, buf);
#if defined(UNIX) || defined(VAXC)
  if (len & (sizeof(WORD) - 1))
  {
    fprintf(stderr, "bad string length: %d\n", len);
    exit(1);
  }
#endif
}

/* do_cstring - read/display counted string */

void 
do_cstring(char *str)
{
  WORD len;

  eread(fd, &len, sizeof(len));
  do_string(str, len);
}

void 
do_nullstring(char *str)
{
  char buf[BUFSIZ];
  int i;
  char c;

  printf("%s", str);

  for (i = 0;; i++)
  {
    eread(fd, &buf[i], 1);
    if (buf[i] == 0)
      break;
  }

  printf("string = \"%s\"\n", buf);
}


/* do_acceltable - process accelator table */

void 
do_acceltable()
{
  BYTE fFlags = 0;
  WORD key;
  WORD cmd;

  printf("\naccelerator entries\n");

  /* Process table entries */
  while (!(fFlags & 0x08))
  {
    fFlags = do_byte("fFlags = 0x%x, ");
    key    = do_word("key = 0x%x, ");
    cmd    = do_word("cmd = 0x%x\n");
  }
}

/* do_strings - process string resource */

void 
do_strings()
{
  WORD nindex;

  /* Read number of string index blocks */

  nindex = do_word("nindex = %d\n");

  /*
   * Strings are kept in a contiguous (id, variable-length
   * string) table, sorted on string id. In order to speed up
   * string access, the strings are preceded by a couple of
   * blocks that delimit string id subranges. 
   */

  while (nindex-- > 0)
  {
    INDEX index;
    long where;
    WORD id;

    /* Process string index block */

    putchar('\n');
    do_group(&index);

    /* Show strings controlled by this index block */

    where = tell(fd);
    lseek(fd, index.ulSeekPos, 0);	/* skip to strings */

    while (tell(fd) < index.ulSeekPosEnd)
    {
      id = do_word("WORD id = %d;	");
      do_cstring("");
    }
    if (nindex > 0)
      lseek(fd, where, 0);	/* back to next index block */
  }
}

/* do_group - process string index block */

void 
do_group(INDEX * p)
{
  eread(fd, p, sizeof(*p));
  printf("int minRange = %d\n", p->minRange);
  printf("int maxRange = %d\n", p->maxRange);
  printf("ulong ulSeekPos = %lu\n", p->ulSeekPos);
  printf("ulong ulSeekPosEnd = %lu\n", p->ulSeekPosEnd);
}

/* do_dialog - process dialog data */

void 
do_dialog()
{
  WORD nitems;
  WORD id;
  WORD xdlg, ydlg, cxdlg, cydlg;
  WORD attr;
  DWORD style;

  style = do_dword("DWORD style = 0x%lx\n");
  nitems = do_byte("\n%d items\n");

  do_word("WORD x = %u; ");
  do_word("y = %u; ");
  do_word("cx = %u; ");
  do_word("cy = %u\n");

  do_nullstring("menu: ");
  do_nullstring("class:   ");
  do_nullstring("caption: ");

#define DS_SETFONT  0x40L
  if (style & DS_SETFONT)
  {
    do_short("Point size = %u\n");
    do_nullstring("font: ");
  }

  if (!bWindowsCompatDlg)
    do_word("WORD attr   = %u\n");


  while (nitems-- > 0)
  {
    WORD iCurrCtrlType;
    WORD x, y, cx, cy;
    WORD id;
    DWORD style;
    BYTE nInfoBytes;

    x = do_word("WORD  x = %u; ");
    y = do_word("y = %u; ");
    cx = do_word("cx = %u; ");
    cy = do_word("cy = %u\n");
    id = do_word("WORD  id    = %d\n");
    style = do_dword("DWORD style = 0x%lx\n");
    do_nullstring("class:   ");
    do_nullstring("caption: ");

    eread(fd, &nInfoBytes, 1);
    if (nInfoBytes)
    {
      char *s = malloc((int) nInfoBytes);

      eread(fd, s, nInfoBytes);
      free(s);
    }
    if (!bWindowsCompatDlg)
      attr = do_word("WORD  attr  = %u\n");
  }
}

/* do_resindex - process resource index table */

void 
do_resindex()
{
  RCSTRING rc;

  rc.idString = do_word("\nWORD id = %d; ");
  do_cstring("");
}
